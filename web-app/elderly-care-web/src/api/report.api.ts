import { appointmentApi } from "./appointment.api";
import { medicationService } from "../services/medication.service";
import { reminderApi } from "./reminder.api";
import { notificationApi } from "./notification.api";
import {
    type ComprehensiveReport,
    type TimeRange,
    type DateRange
} from "../types/report.types";

import { reportMockService } from "./report.mock";

/**
 * REPORT API SERVICE
 * 
 * Aggregates data from multiple domain services to provide audit insights.
 */
export const reportApi = {
    /**
     * Generates a comprehensive report based on a time range.
     * In a real system, this would be a single heavy backend query.
     * Here, we orchestrate it across existing clients.
     */
    generateReport: async (range: TimeRange, customRange?: DateRange): Promise<ComprehensiveReport> => {
        if (import.meta.env.DEV) {
            return await reportMockService.generateMockReport(range);
        }
        const { start, end } = reportApi.calculateDates(range, customRange);

        // Fetch all relevant data concurrently
        const [appts, meds, rems, notifs] = await Promise.all([
            appointmentApi.getAll(),
            medicationService.getMedications(), // Using service for consistency with Dashboard
            reminderApi.getReminders(),
            notificationApi.getNotifications("00000000-0000-0000-0000-000000000001", 1, 100) // Backend max is 100
        ]);

        // 1. Process Reminder Performance
        const reminderPerformance = reportApi.processReminderPerformance(rems.data, start);

        // 2. Process Notification Delivery
        const notificationDelivery = reportApi.processNotificationDelivery(notifs.data, start);

        // 3. Process Medication Adherence
        const medicationAdherence = reportApi.processMedicationAdherence(meds, rems.data, notifs.data, start);

        // 4. Process Appointment Compliance
        const appointmentCompliance = reportApi.processAppointmentCompliance(appts.data, rems.data);

        // 5. Process System Health
        const systemHealth = reportApi.processSystemHealth(notifs.data, start);

        return {
            reminderPerformance,
            notificationDelivery,
            medicationAdherence,
            appointmentCompliance,
            systemHealth,
            metadata: {
                range: range === 'custom' ? `${start.toLocaleDateString()} - ${end.toLocaleDateString()}` : range,
                timestamp: new Date().toISOString(),
                version: "1.0.0"
            }
        };
    },

    calculateDates: (range: TimeRange, customRange?: DateRange): DateRange => {
        const end = new Date();
        let start = new Date();

        switch (range) {
            case 'today':
                start.setHours(0, 0, 0, 0);
                break;
            case '7d':
                start.setDate(end.getDate() - 7);
                break;
            case '30d':
                start.setDate(end.getDate() - 30);
                break;
            case 'custom':
                if (customRange) return customRange;
                start.setDate(end.getDate() - 7); // Fallback
                break;
        }
        return { start, end };
    },

    processReminderPerformance: (rems: any[], start: Date) => {
        const filtered = rems.filter(r => {
            const date = new Date(r.scheduledTime);
            return date >= start;
        });

        const totalCreated = filtered.length;
        const done = filtered.filter(r => r.status === 1); // Done
        const missed = filtered.filter(r => r.status === 2); // Missed
        const pending = filtered.filter(r => r.status === 0); // Pending

        return {
            totalCreated,
            triggeredOnTime: totalCreated > 0 ? Math.round((done.length / totalCreated) * 100) : 100,
            missedTriggers: missed.length,
            lateTriggers: 0, // Mocking latency data for now
            autoGenerated: filtered.filter(r => r.type === 0).length, // Medication type
            manuallyCreated: filtered.filter(r => r.type !== 0).length,
            dailyHistory: [], // To be populated if needed for charts
            outcomeBreakdown: [
                { name: 'On-Time', value: done.length },
                { name: 'Missed', value: missed.length },
                { name: 'Pending', value: pending.length }
            ]
        };
    },

    processNotificationDelivery: (notifs: any[], start: Date) => {
        const filtered = notifs.filter(n => {
            const date = new Date(n.sentAt);
            return date >= start;
        });

        const totalSent = filtered.length;
        const delivered = filtered.filter(n => n.status >= 1); // Delivered and beyond
        const failed = filtered.filter(n => n.status === 4); // Failed
        const read = filtered.filter(n => n.status === 2 || n.status === 3);
        const acknowledged = filtered.filter(n => n.status === 3);

        return {
            totalSent,
            deliveredCount: delivered.length,
            failedCount: failed.length,
            readRate: totalSent > 0 ? Math.round((read.length / totalSent) * 100) : 0,
            acknowledgementRate: totalSent > 0 ? Math.round((acknowledged.length / totalSent) * 100) : 0,
            averageRetries: totalSent > 0 ? filtered.reduce((acc, n) => acc + (n.retryCount || 0), 0) / totalSent : 0,
            maxRetries: filtered.reduce((max, n) => Math.max(max, n.retryCount || 0), 0),
            channelBreakdown: [
                { name: 'Push', value: filtered.filter(n => n.deliveryChannel === 0).length },
                { name: 'Email', value: filtered.filter(n => n.deliveryChannel === 1).length },
                { name: 'In-App', value: filtered.filter(n => n.deliveryChannel === 2).length },
                { name: 'SMS', value: filtered.filter(n => n.deliveryChannel === 3).length }
            ],
            recipientBreakdown: [
                { name: 'Elderly', value: filtered.filter(n => n.recipientType === 0).length },
                { name: 'Caregiver', value: filtered.filter(n => n.recipientType === 1).length }
            ]
        };
    },

    processMedicationAdherence: (meds: any[], rems: any[], notifs: any[], start: Date) => {
        const medReminders = rems.filter(r => r.type === 0);
        const missed = medReminders.filter(r => r.status === 2 && new Date(r.scheduledTime) >= start).length;
        const acknowledged = notifs.filter(n => n.status === 3 && n.sentAt >= start.toISOString()).length;

        return {
            activeMedications: meds.filter(m => m.status === 'Active').length,
            missedRemindersCount: missed,
            acknowledgedCount: acknowledged,
            pauseResumeHistoryCount: 0, // Meta-stat
            adherenceTrend: [] // Dynamic based on daily filters
        };
    },

    processAppointmentCompliance: (appts: any[], rems: any[]) => {
        const apptReminders = rems.filter(r => r.type === 1);
        const withReminders = appts.filter(a => apptReminders.some(r => r.referenceId === a.id)).length;

        return {
            totalAppointments: appts.length,
            withReminders,
            withoutReminders: appts.length - withReminders,
            deliveredBefore: withReminders, // Simplified
            noShowRiskCount: appts.filter(a => apptReminders.some(r => r.referenceId === a.id && r.status === 2)).length
        };
    },

    processSystemHealth: (notifs: any[], start: Date) => {
        const failed = notifs.filter(n => n.status === 4 && new Date(n.sentAt) >= start);

        const reasonMap = new Map<string, number>();
        failed.forEach(f => {
            const reason = f.failureReason || 'Network Timeout';
            reasonMap.set(reason, (reasonMap.get(reason) || 0) + 1);
        });

        return {
            failuresByReason: Array.from(reasonMap.entries()).map(([reason, count]) => ({ reason, count })),
            retrySuccessRate: 85, // Mocked percentage
            averageDelayMs: 450, // Mocked latency
            peakFailureWindows: [
                { window: '08:00 - 10:00', count: 5 },
                { window: '20:00 - 22:00', count: 3 }
            ]
        };
    }
};
