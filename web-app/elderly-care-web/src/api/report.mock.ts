import { medicationService } from '../services/medication.service';
import { reminderApi } from './reminder.api';
import { notificationApi } from './notification.api';
import type { TimeRange, ComprehensiveReport } from '../types/report.types';

// MOCK DATA – DEV ONLY – DO NOT SHIP

/**
 * REPORT MOCK GENERATOR
 * 
 * Responsibility: Generate analytics from cross-domain mock data.
 * Purely read-only aggregation.
 */
export const reportMockService = {
    generateMockReport: async (range: TimeRange): Promise<ComprehensiveReport> => {
        // Logic should mimic the real reportApi but explicitly using mocks if needed
        // For consistency, we use the services/APIs which should already be pointing to mocks in DEV.

        const [meds, rems, notifs] = await Promise.all([
            medicationService.getMedications(),
            reminderApi.getReminders(),
            notificationApi.getNotifications("00000000-0000-0000-0000-000000000001", 1, 100)
        ]);

        const totalReminders = rems.data.length;
        const missedReminders = rems.data.filter(r => r.status === 2).length;
        const adherenceRate = totalReminders > 0
            ? Math.round(((totalReminders - missedReminders) / totalReminders) * 100)
            : 100;

        return {
            reminderPerformance: {
                totalCreated: totalReminders,
                triggeredOnTime: adherenceRate,
                missedTriggers: missedReminders,
                lateTriggers: 0,
                autoGenerated: rems.data.filter(r => r.type === 0).length,
                manuallyCreated: rems.data.filter(r => r.type === 1).length,
                dailyHistory: [],
                outcomeBreakdown: [
                    { name: 'On-Time', value: totalReminders - missedReminders },
                    { name: 'Missed', value: missedReminders }
                ]
            },
            notificationDelivery: {
                totalSent: notifs.data.length,
                deliveredCount: notifs.data.filter(n => n.status >= 1).length,
                failedCount: notifs.data.filter(n => n.status === 4).length,
                readRate: 85,
                acknowledgementRate: 70,
                averageRetries: 1.2,
                maxRetries: 3,
                channelBreakdown: [],
                recipientBreakdown: []
            },
            medicationAdherence: {
                activeMedications: meds.filter(m => m.status === 'Active').length,
                missedRemindersCount: missedReminders,
                acknowledgedCount: notifs.data.filter(n => n.status === 3).length,
                pauseResumeHistoryCount: 2,
                adherenceTrend: []
            },
            appointmentCompliance: {
                totalAppointments: 8,
                withReminders: 6,
                withoutReminders: 2,
                deliveredBefore: 5,
                noShowRiskCount: 1
            },
            systemHealth: {
                failuresByReason: [
                    { reason: 'Provider Timeout', count: 3 },
                    { reason: 'Invalid Phone Number', count: 1 }
                ],
                retrySuccessRate: 92,
                averageDelayMs: 320,
                peakFailureWindows: []
            },
            metadata: {
                range: range,
                timestamp: new Date().toISOString(),
                version: "1.2.0-mock"
            }
        };
    }
};
